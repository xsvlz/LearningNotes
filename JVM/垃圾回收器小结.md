# 垃圾回收器小结

## 一、一些基本概念

### 判断是否可回收

判断可回收通常有两种方法，分别是引用计数法和可达性分析算法。

其中，**引用计数法**需要维护一个计数器，从理论上来说效率更高，但需要进行非常多的额外处理才能保证正确工作，比如==循环引用问题==。

主流的Java虚拟机都没有选用引用计数法。

而**可达性分析算法**是通过一系列的`GC Roots`开始，根据引用关系向下搜索引用链，如果某个对象从GC Roots无法到达，就会被判定为可回收对象

### 可作为GC Roots的对象

1. 虚拟机栈中引用的对象
2. 方法区中类的静态属性引用的对象
3. 方法区中的常量引用的对象（例如串池中的引用）
4. 本地方法栈中JNI引用的对象
5. Java虚拟机内部的引用（基本数据类型对应的Class对象、常驻的异常对象等，以及系统类加载器）
6. 被`synchronized`修饰的对象。



### 四种引用

**强引用：**最普遍的引用，通常使用new关键字创建，只要引用存在就不会被回收。

**软引用：**内存足够时不会被回收，如果垃圾回收后内存还不足，**只存在软引用**的对象会被回收。

**弱引用：**下一次垃圾回收时，**只存在弱引用**的对象一定会被回收。

**虚引用：**不会对对象的生存产生任何影响，也不能用它获取对象实例，使用虚引用的唯一作用是在对象被回收时可以得到通知。



### 回收方法区（类的卸载）

类的回收和对象不同，即使满足了回收条件，虚拟机也不一定会执行回收动作。可以使用一些参数来控制这一行为。

如果想回收一个类，需要**同时满足**以下三个条件：

1. 该类的所有实例已经被回收
2. 加载该类的类加载器已经被回收
3. 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。



## 二、垃圾收集算法

### 分代收集理论

1. 弱分代假说：绝大多数对象都是朝生夕灭的。
2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。
3. 跨代引用假说：跨代引用相对于同代引用来说仅占极少数。
   - 推论：存在相互引用关系的两个对象，应该是倾向于同时生存或同时消亡的。

### 垃圾回收算法

1. 标记-清除算法
   - 最基础的收集算法：后续的收集算法大多以标记-清除为基础并进行改造。
   - 缺点：执行效率不稳定、内存碎片化（可能导致大对象无法分配而提前触发另一次垃圾回收）
2. 标记-整理算法
   - 避免了碎片化问题
   - 开销大，必须暂停用户进程进行对象移动
   - 老年代通常采用
3. 标记-复制算法（复制算法）
   - 将内存分为两块，收集时把存活的对象复制到另一块内存区域，然后一次性清理使用过的内存空间
   - 优点：当**多数对象可回收**时，只需要复制少量的对象（反之则成为了缺点，这也是老年代不采用复制算法的原因）
   - 缺点：需要浪费大量的额外内存空间
   - 分代收集的方式：Eden和survivor区大小比例为8:1，可用空间达到了90%（survivor区有两个，From和To，其中一个用于复制算法）。但这种方式需要老年代空间作为担保，当Survivor空间不足以容纳MinorGC存活的对象的时候，就要分配到老年代。



### 记忆集与卡表

所有涉及部分区域收集行为的垃圾收集器都存在跨代引用类似的问题。典型的例如G1，ZGC等。

**记忆集**是一种用于记录从非收集区域指向收集区域的指针集合组成的抽象数据结构。

**卡表**是目前最常使用的一种记忆集的实现形式，可以记录某一块区域内是否有对象存在跨代指针。

卡表的最简单形式可以只是一个字节数组，数组中的每一个元素都对应地标识着内存区域中一块特定大小的内存块，这个内存块被称为**卡页**。HotSpot虚拟机中使用的卡页大小为512字节。

一个卡页中通常包含不止一个对象，只要卡页中有一个对象存在跨代指针，就把它所对应的卡表中的数组元素的值置为1（称为“变脏”）。在垃圾收集发生时，只要筛选出卡表中变脏的元素并把它们加入到GC Roots中一并扫描。



### 并发的可达性分析

可达性分析算法理论上要求全过程都一个能保障一致性的快照中才能进行分析，但这也意味着必须要暂停所有的用户线程才能进行，而堆越大，存储的对象越多，对象图结构越复杂，产生的停顿时间自然就更长。为了降低用户线程的停顿，我们首先要理解为什么必须在一个能保证一致性的快照上才能进行对象图的遍历。引入**三色标记**：

- **白色**：表示对象尚未被垃圾收集器访问过。
  - 在分析结束时，仍然为白色的对象即为不可达，会被垃圾回收。
- **黑色**：表示对象已经被垃圾收集器访问过，并且这个对象的所有引用都已经扫描过。
  - 黑色对象是安全存活的
  - **黑色对象不可能不经过灰色对象而指向某个白色对象**。（因为黑色已经访问了所有引用，与白色未被访问矛盾）
- **灰色**：表示对象已经被垃圾收集器访问过，但是这个对象上至少还有一个引用没有被扫描过。



如果用户线程和标记线程并发执行，那么在标记的过程中，用户线程也在修改引用关系，即对象图的结构，那么就会存在两种问题：

1. 把原本已经死亡的对象标记为存活。
2. 把原本存活的对象标记为已死亡。

其中，第一种情况虽然产生了一些浮动垃圾，但并不会对系统造成严重的影响，下一次垃圾收集时把这些垃圾清理掉即可。但把存活的对象标记成死亡的，即”对象消失“，就会对程序造成致命性的后果。

**当且仅当**同时满足以下条件时，会出现”**对象消失**”问题，即黑色对象误判为白色。

1. **赋值器插入了一条或多条从黑色对象到白色对象的新引用。**
2. **赋值器删除了全部的从灰色对象到一个白色对象的直接或间接引用。**

要想解决对象消失的问题，只需要破坏这两个条件的其中一个即可。针对这两个条件产生了两种解决方案：增量更新和原始快照。

- ==**增量更新**==，目的是破坏第一个条件：当黑色对象新插入指向白色对象的引用时，就把它记录下来，当并发扫描结束时，再把这些记录的引用中的黑色对象为根重新扫描一次。这可以理解为 **黑色对象只要插入了指向白色对象的引用之后，它就变成了灰色对象**。
- ==**原始快照**==，目的是破坏第二个条件：当灰色对象要删除指向白色对象的引用关系时，会把这个要删除的引用记录下来，等待并发扫描结束后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这可以理解为 **无论引用关系删除与否，都按照刚开始扫描那一刻的快照图来进行搜索**。



## 三、垃圾收集器

### 两套经典的垃圾收集器：

![](http://img.longzhuang.top/20-07-11-b5b0bbedfe35d116a6978e4f45591d32.png)

#### Serial

- 最基础的垃圾收集器
- 单线程，需要暂停用户线程
- 新生代收集器，采用复制算法
- 客户端模式的默认收集器

#### ParNew

- Serial的并行版本
- JDK9之后只有它可以和CMS配合工作（之前Serial也可以）

#### Parallel Scavenge

- 新生代收集器，采用复制算法
- 并行收集
- 目标是吞吐量可控（吞吐量优先收集器）

#### Serial Old

- Serial收集器的老年代版本
- 单线程
- 采用标记-整理算法
- CMS收集器失败的后备预案

#### Parallel Old

- Parallel Scavenge的老年代版本
- 为了配合Parallel Scavenge实现吞吐量最大化

### CMS垃圾收集器

全称 Concurrent Mark Sweep，即并发标记清除。

- 老年代收集器
- 目标是获取最短回收停顿时间
- 基于**标记-清除**算法

CMS垃圾回收器的过程分为四步：

1. **初始标记**：仅标记GC Roots直接关联的对象
2. **并发标记**：从GC Roots直接关联对象开始遍历整个对象图
3. **重新标记**：采用增量更新方式
4. **并发清除**：删除已死亡对象，由于不需要移动对象，因此可以与用户线程并发执行

其中，初始标记和重新标记仍需要STW。而耗时最长的并发标记和并发清除都是与用户线程一起并发进行。

#### CMS的缺点：

- 并发阶段占用了一部分线程，**降低了总吞吐量**。
  - CMS默认回收线程数是$(处 理 器 核 心 数+3)/4$，当处理器核心数小于4时会对用户程序造成较大影响。
- 无法处理浮动垃圾，有可能出现并发收集失效从而触发停止用户线程的Full GC
- 基于标记-清除算法，容易产生碎片，导致提前触发Full GC



### G1垃圾收集器

- 面向服务端，JDK9服务端模式下默认收集器
- 目的是建立**停顿时间模型**，即能够支持在长度为M毫秒的时间片段内，消耗在垃圾收集器上的时间不超过N毫秒的目标。

G1收集器跳出了新生代和老年代的模式，把Java堆划分成多个大小相等的独立的Region。每个Region都可以**根据需要**扮演Eden、Survivor或者老年代空间

Region中还有一类Humongous区域，专门用于存储大对象。通常认为如果一个对象的大小超过了一个Region的一半，就认为是大对象。同时如果一个对象的大小超过了整个Region的容量，会被放在**多个连续的Humongous Region**中。

**G1的大多数行为都把Humongous Region作为老年代的一部分来看待。**

G1中的老年代和新生代不再是固定的了，它们都是一系列区域的同台集合。==G1优先回收价值收益最大的那些Region==。

G1回收器也存在并发标记阶段，**使用原始快照(SATB)算法来实现与用户线程互不干扰。**

G1还为每一个Region设计了两个名为TAMS(Top At Mark Start)的指针，把Region中的一部分空间划分出来用于并发回收过程中新对象的分配，即**并发回收时新分配的对象地址必须在这两个指针位置以上**，G1默认这部分对象存活。

#### G1收集器的四个步骤：

1. **初始标记**：标记和GC Roots直接关联的对象，并修改TAMS指针的值。
   - 这段时间耗时很短，而且是**借用进行Minor GC的时候同步完成的**，因此实际上没有额外的停顿
2. **并发标记**：扫描整个对象图
3. **最终标记**：处理并发阶段的少量原始快照记录。
4. **筛选回收**：根据期望的停顿时间制定回收计划，选择多个Region作为回收集，把存活对象复制到空的Region中，然后清理掉旧Region的全部空间。

#### G1的优缺点

- 不会产生内存碎片
- 垃圾收集的内存占用和额外负载都比CMS高
  - CMS只有一份卡表，而G1需要在每个Region维护一份卡表。可能占用堆空间的20%甚至更多
  - 为了实现原始快照，需要使用写前屏障跟踪并发时的指针变化情况。但原始快照能减少并发标记和重新标记阶段的开销



### ZGC收集器

ZGC收集器是
- 基于Region内存布局的
- 不设分代的
- 使用了读屏障、染色指针和内存多重映射等技术来实现的==可并发的标记-整理算法==的
- 以低延迟为首演目标的

垃圾收集器



ZGC把Region分为了小中大三种类型的容量：

- **小型Region**：容量固定为2MB，用于放置小于256KB的对象
- **中型Region**：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象
- **大型Region**：容量可动态变化，但必须为2MB的整数倍，用于放置4MB及以上的对象

从上述介绍也可以看出，**大型Region的容量完全有可能小于中型Region**

ZGC的标志性设计是**染色指针技术**，它直接把标记信息记录在引用对象的**指针上**。它利用了64位机器上可用的46位（Linux下）物理地址空间的高4位用来存储标志信息，包括它**引用对象的三色标记状态**、**是否进入了重分配集**、**是否只能通过`finalize()`方法才能被访问到**。

染色指针的限制：

- 占用了4位地址空间，直接导致ZGC能管理的内存不能超过4TB
- 不支持32位平台
- 不支持压缩指针等

ZGC的全部四个阶段都是可以并发执行的：

1. **并发标记**：遍历对象图做可达性分析，前后也要进行短暂的停顿（类似初始标记和最终标记）。不同的是，**ZGC的标记是在指针上进行**，更新Marked0和Marked1标志位
2. **并发预备重分配**：统计出本次收集过程要清理哪些Region，将这些Region组成**重分配集**。
   - ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取G1中记忆集的维护成本
3. **并发重分配**：ZGC的核心阶段
   - 把重分配集中的存活对象复制到新Region上，并为重分配集中的每个Region维护一个==**转发表**==，**记录从旧对象到新对象的转换关系**。
   - 如果用户线程此时并发访问了位于重分配集的对象，这次访问就会被预置的内存屏障截获，根据转发表将访问转发到新复制的对象上，同时更新该引用的值，使它直接指向新对象。这称为指针的==自愈==能力。**只有第一次访问旧对象会陷入转发**。
   - 这样做的优点是一旦分配集中的某个Region的存活对象复制完成，这个Region就可以立即释放用于新对象的分配，即使堆中引用旧对象的指针还没有更新，也可以通过转发表自愈。
4. **并发重映射**：修正整个堆中指向重分配集中的旧对象的所有引用。由于指针的自愈，这一阶段任务并不紧急。
   - ZGC把这一阶段要做的任务合并到了下一次垃圾收集循环中的并发标记阶段来完成（因为它们都需要遍历所有对象）。





