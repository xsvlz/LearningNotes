# 198. 打家劫舍

2020-05-29 每日一题

> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
>
> 示例 1:
>
> ```
> 输入: [1,2,3,1]
> 输出: 4
> 解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
>      偷窃到的最高金额 = 1 + 3 = 4 。
> ```
>
>
> 示例 2:
>
> ```
> 输入: [2,7,9,3,1]
> 输出: 12
> 解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
>      偷窃到的最高金额 = 2 + 9 + 1 = 12 。
> ```
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/house-robber



## 动态规划

用`robs[i][0]和robs[i][1]`表示每个节点偷和不偷所带来的最大值

最开始，`robs[0][0] = 0, robs[0][1] = nums[0]`

对于后续的每个节点，都面临偷和不偷两个选择。

- 如果选择了`偷`，那么只能使用上一个节点的`不偷`的价值加上`当前节点的价值`
- 如果选择了`不偷`，那么当前节点的价值就是上一个节点的偷和不偷中的最大值

以此类推，返回最后一个节点偷和不偷当中的最大值，就是所有节点能够达到的最大值。

```java
class Solution {
    public int rob(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return 0;
        }
        int[][] robs = new int[len][2];
        robs[0][0] = 0;
        robs[0][1] = nums[0];
        for (int i = 1; i < len; i++) {
            robs[i][0] = Math.max(robs[i - 1][0], robs[i - 1][1]);
            robs[i][1] = robs[i - 1][0] + nums[i];
        }
        return Math.max(robs[len - 1][0], robs[len - 1][1]);
    }
}
```

