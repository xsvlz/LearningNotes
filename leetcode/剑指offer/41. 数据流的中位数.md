# 41. 数据流的中位数

> 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。
> 例如，
> [2,3,4] 的中位数是 3
> [2,3] 的中位数是 (2 + 3) / 2 = 2.5
> 设计一个支持以下两种操作的数据结构：
> `void addNum(int num)` - 从数据流中添加一个整数到数据结构中。
> `double findMedian()` - 返回目前所有元素的中位数。
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof

这道题目有多种解法。

## 解法1: 使用partition

我们的目的是找到中位数，如果对数据流不加排序处理地存储在数组中，就可以使用partition来找到中位数。由于插入时不排序，所以插入的复杂度为$O(1)$，而查找中位数的复杂度就是$O(n)$。

## 解法2: 插入时排序

我们可以在每次插入时对数组进行排序，这样需要比较和移动数组元素，时间复杂度为$O(n)$,而查找中位数时直接计算下标取出即可，复杂度为$O(1)$

## 解法3: 排序链表

使用链表存储数据，插入时排序，不需要移动结点，但需要$O(n)$的时间进行比较。如果我们再使用两个指针来保存中间结点，那么查找中位数的复杂度就为$O(1)$

## 解法4: 使用优先队列

我们注意到，如果一个序列是有序的，我们可以把它平均分成两个部分，如果是偶数个结点，那么中位数就是左半部分的最大值和右半部分的最小值的平均；如果是奇数个结点，我们可以把左半部分多分一个元素，这时中位数就是左半部分的最大值。

于是我们可以看出，要求中位数，我们不需要将整个序列都排序，只需要关心两个部分的最大值和最小值即可。因此我们可以想到使用优先队列来解决此问题。

左半部分要找最大值，所以可以使用一个大顶堆；右半部分要找最小值，所以使用一个小顶堆。我们在插入元素的时候，先向大顶堆插入，再向小顶堆插入，这样如果元素个数为奇数，那么中位数就从大顶堆取；如果是偶数，就从大顶堆和小顶堆各取一个求平均。

这时我们还会发现一个问题，例如当前元素个数为偶数，下一个元素应该插入到大顶堆中，但是如果这个元素比小顶堆的最小值还大，也就是说它应该属于右半部分时，我们就需要先把它插入到小顶堆中，然后再从小顶堆中取出最小值插入到大顶堆中，这样就保证了两个堆中元素的相对大小关系不变。反之当元素个数为奇数时也一样。

那么我们就可以直接“反其道而行之”，当需要向大顶堆插入时，就先插入到小顶堆中，再从小顶堆取出最小值插入大顶堆；当需要向小顶堆插入时，先插入到大顶堆中，再从大顶堆中取出最大值插入小顶堆。

堆的插入时间复杂度为$O(\log n)$，求中位数只需要查看堆顶元素，复杂度为$O(1)$。

使用PriorityQueue的实现代码：

```java
class MedianFinder {
    
    private Queue<Integer> maxHeap, minHeap;

    /** initialize your data structure here. */
    public MedianFinder() {
        maxHeap = new PriorityQueue<>((o1, o2) -> o2 - o1);
        minHeap = new PriorityQueue<>();
    }
    
    public void addNum(int num) {
        if (maxHeap.size() == minHeap.size()) {
            minHeap.add(num);
            maxHeap.add(minHeap.remove());
        } else {
            maxHeap.add(num);
            minHeap.add(maxHeap.remove());
        }
    }
    
    public double findMedian() {
        if (maxHeap.size() == minHeap.size()) {
            return (maxHeap.peek() + minHeap.peek()) / 2.0;
        } else {
            return (double) maxHeap.peek();
        }
    }
}

```