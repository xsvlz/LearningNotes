# 31. 下一个排列

> 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
>
> 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
>
> 必须原地修改，只允许使用额外常数空间。
>
> 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
> `1,2,3` → `1,3,2`
> `3,2,1` → `1,2,3`
> `1,1,5` → `1,5,1`
>
> 
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/next-permutation



首先我们重点分析一下，什么样的数会是“下一个排列”。

1. 新的排列组成的数要**比当前数字更大**
2. 数字的**增长幅度要尽可能小**

以`123465`为例，找到比当前数字更大的数，只需要把一个大数字向前提即可，这里可以把4和6交换，形成`123645`；也可以把4和5交换，形成`123564`，但实际上下一个数字是`123546`。根据类似的例子，我们可以总结出几条规律：

1. 尽可能靠右地交换，因为越靠右，对整个数值的影响就越小，符合“增长幅度尽可能小”
2. 被交换到前面的这个“大数字”要尽可能小
3. 大数字就位后，其后的元素应该变成升序。因为升序是一段数字的排列中数值最小的

### 算法过程

1. 从后向前，找到第一个相邻的升序元素对`i,j`，使得`nums[i] > nums[j]`，这样从`j`往后的序列一定是降序的。这样找的目的是因为`j`后面的元素往前提，最少要提到`i`才能使序列值更大，这样就能进一步找到增长幅度最小的那个。如果这一步找不到升序元素对，就直接进入第四步。
2. 在`j`（包含）以后的元素中，找到**第一个**大于`nums[i]`的元素，这就是要和`nums[i]`交换的元素。
3. 交换第2步的两个元素
4. 此时，`j`开始的序列一定是降序，把它转换成升序。

### 代码实现

```java
class Solution {
    public void nextPermutation(int[] nums) {
        if (nums.length < 2) {
            return;
        }
        for (int i = nums.length - 1; i > 0; i--) {
            if (nums[i - 1] < nums[i]) { // 找到一个相邻升序对
                for (int j = nums.length - 1; j >= i; j--) {
                    if (nums[j] > nums[i - 1]) {
                        swap(nums, i - 1, j);	// 交换元素
                        reverse(nums, i);		// 升序处理
                        return;
                    }
                }
            }
        }
        reverse(nums, 0);
    }
    
    private void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
    
    private void reverse(int[] arr, int start) {
        for (int l = start, r = arr.length - 1; l <= r; l++, r--) {
            swap(arr, l, r);
        }
    }
}
```













