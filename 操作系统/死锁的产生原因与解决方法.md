# 死锁的产生原因与解决方法

## 产生死锁的原因

1. 系统资源不足
2. 资源分配不当
3. 进程推进顺序的不合理

## 产生死锁的必要条件

1. **互斥条件**：一个资源每次只能被一个进程使用。
2. **请求与保持条件**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. **不剥夺条件**：进程已获得的资源，在末使用完之前，不能强行剥夺。
4. **循环等待条件**：若干进程之间形成一种头尾相接的循环等待资源关系。

## 解决死锁的方法

有三种方法可以处理死锁问题：

1. **死锁预防**：采用某种策略来消除条件1-4中的一个条件的出现来防止死锁。
2. **死锁避免**：基于资源分配的当前状态做动态选择来避免死锁。
3. **死锁检测**：试图去检测死锁的存在并试图从死锁中恢复出来。

### 死锁预防

死锁预防是通过破坏死锁出现的必要条件来防止死锁的出现，从源头解决死锁问题。

1. **一次性申请所有资源**（破坏请求与保持条件）。缺点：如果某些资源的使用很少，使用这种方式时会在整个进程的运行期间，该资源都被占用，资源的利用率会比较低。
2. **可剥夺资源**（破坏不剥夺条件）：当进程新申请的资源不满足时，释放已经申请的资源。缺点：有些资源如果需要连续使用，强行剥夺一分配的资源可能出现问题，例如强行剥夺打印机资源可能导致打印的不连续。

3. **资源有序分配**（破坏循环等待条件）：系统为资源编号，进程在申请资源时只能按照顺序申请资源，这样就不会出现某个线程持有资源2的时候等待资源1的情况了。

### 死锁避免

死锁避免是属于事先预防策略，但并不会事先采取某种措施破坏死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。这种方法限制条件比较弱，可以获得较好的系统性能。

- 如果一个进程的请求会导致死锁，则不启动此进程。
- 如果一个进程增加资源的请求会导致死锁，则不允许此分配。

最著名的死锁避免算法：银行家算法

### 死锁检测和解除

死锁预防和死锁避免嗾使以牺牲系统效率和浪费资源为代价的，这与操作系统的设计目标相违背。而死锁检测策略则完全相反，它不采取任何限制错误来保证系统不进入死锁状态，即**允许死锁发生**，但操作系统不断地监督进程的进程路径，判断死锁是否真的发生，一旦死锁发生，则采取专门的措施解除死锁，并以最小代价使得整个系统恢复正常。

检测死锁可以通过检查资源分配图中是否存在环路来进行判断。

当检测到死锁时，有如下几种方式可以恢复：

- 资源剥夺法：剥夺陷入死锁的进程所占用的所有资源，但并不撤销进程，直到死锁解除。
- 进程回退法：根据系统保存的检查点让所有的进程回退，直到足以解除死锁，这种措施要求系统建立保存检查点、回退及重启机制。
- 进程撤销法：
    - 撤销陷入死锁的所有进程，解除死锁，继续运行
    - 逐个撤销陷入死锁的进程，回收其资源并进行重新分配，直到死锁解除。
- 系统重启法：结束所有进程并重启操作系统。