# MySQL锁机制(未完)

![](http://img.longzhuang.top/20200715175307.jpg)

[^ref_lock]: 本文参考掘金作者:公众号非科班的科班<br>连接：https://juejin.im/post/5ef0aac8e51d4574113a0447

### 锁的种类[^ref_lock]

Mysql中锁的分类按照不同类型的划分可以分成不同的锁，按照**「锁的粒度」**划分可以分成：**「表锁、页锁、行锁」**；按照**「使用的方式」**划分可以分为：**「共享锁」**和**「排它锁」**；按照思想的划分：**「乐观锁」**和**「悲观锁」**。

#### 1. 表锁

**表锁**是粒度最大的锁，开销小，加锁快，不会出现死锁，但是由于粒度太大，因此造成锁的冲突几率大，并发性能低。

Mysql中`MyISAM`储存引擎就支持表锁，MyISAM的表锁模式有两种：**表共享读锁**和**表独占写锁**。

当一个线程获取到`MyISAM`表的**读锁**的时候，会阻塞其他用户对该表的写操作，但是不会阻塞其它用户对该用户的读操作。

相反的，当一个线程获取到`MyISAM`表的**写锁**的时候，就会阻塞其它用户的读写操作对其它的线程具有排它性。

#### 2. 页锁（很少使用）

「页锁」的粒度是介于行锁和表锁之间的一种锁，因为页锁是在BDB中支持的一种锁机制，也很少没人提及和使用。

#### 3. 行锁

行锁是粒度最小的锁机制，行锁的加锁开销性能大，加锁慢，并且可能出现死锁，但是行锁的锁冲突的几率低，并发性能高。

行锁是`InnoDB`默认的支持的锁机制，MyISAM**不支持**行锁，这个也是InnoDB和MyISAM的区别之一。
行锁在使用的方式上可以划分为：**共享读锁（S锁）**和**排它写锁（X锁）**。

当一个事务对Mysql中的一条数据行加上了**S锁**，当前事务不能修改该行数据只能执行度操作，其他事务只能对该行数据加S锁不能加X锁。

若是一个事务对一行数据加了**X锁**，该事物能够对该行数据执行读和写操作，其它事务不能对该行数据加任何的锁，既不能读也不能写。

#### 悲观锁和乐观锁

悲观锁和乐观锁是在很多框架都存在的一种思想。数据库管理系统中为了控制并发，保证在多个事务执行时的数据一致性以及事务的隔离性，使用悲观锁和乐观锁来解决并发场景下的问题。

乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

- 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作
- 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。


Mysql中悲观锁的实现是基于Mysql自身的锁机制实现，而**乐观锁需要程序员自己去实现的锁机制**，最常见的乐观锁实现就锁机制是**使用版本号实现**。

### MyISAM

MyISAM不支持行锁，它默认支持两种表锁，即读锁和写锁。Mysql中平时读写操作都是隐式的进行加锁和解锁操作，Mysql已经自动帮我们实现加锁和解锁操作了。

#### MyISAM的锁调度：

MyISAM存储引擎中，假如同时一个读请求，一个写请求过来的话，它会**优先处理写请求**，因为MyISAM存储引擎中认为写请求比都请求重要。

这样就会导致，假如大量的读写请求过来，就会导致读请求长时间的等待，或者"线程饿死"，因此**MyISAM不适合运用于大量读写操作的场景**，这样会导致长时间读取不到用户数据，用户体验感极差。

可以通过设置`low-priority-updates`参数，设置请求链接的优先级，使得Mysql优先处理读请求。

### InnoDB

InnoDB中除了有**表锁**和**行级锁**的概念，还有**Gap Lock（间隙锁）**、**Next-key Lock锁**

**间隙锁**主要用于范围查询的时候，锁住查询的范围，并且间隙锁也是解决幻读的方案。

InnoDB中的**行级锁是对索引加的锁**， _在不通过索引查询数据的时候，InnoDB就会使用表锁_ 。但是通过索引查询的时候是否使用索引，还要看Mysql的执行计划，Mysql的优化器会判断是一条sql执行的最佳策略。

#### InnoDB间隙锁

当我们使用范围条件查询而不是等值条件查询的时候，InnoDB就会给符合条件的范围索引加锁，在条件范围内并不存的记录就叫做**间隙（GAP）**

在事务的四大隔离级别中，可重复读级别会产生幻读的现象，只能通过提高隔离级别到串行化来解决幻读现象。但是**MySQL中的可重复读已经解决了幻读问题**，它通过引入间隙锁的实现来解决幻读，通过给符合条件的间隙加锁，防止再次查询的时候出现新数据产生幻读的问题。

例如我们执行下面的sql语句，就会对id大于100的记录加锁，在id>100的记录中肯定是有不存在的间隙
```sql
Select * from  employee where id> 100 for update;
```
